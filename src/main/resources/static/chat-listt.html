<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chat List</title>
    <link rel="stylesheet" href="style.css">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const chatListDiv = document.getElementById('chatList');

            // Initial load
            chatListDiv.innerHTML = `
        <p class="empty-message">
          There is no created room yet. Click the "Find User" button to look for a user and start a chat.
        </p>
      `;
            loadChatList();

            function loadChatList() {
                fetch(`/api/chat-list/chats`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to fetch chats: ' + response.status);
                        }
                        return response.json();
                    })
                    .then(chats => {
                        if (chats.length === 0) {
                            chatListDiv.innerHTML = `
                <p class="empty-message">
                  There is no created room yet. Click the "Find User" button to look for a user and start a chat.
                </p>
              `;
                        }
                        // else {
                        //     updateChatList(chats);
                        // }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        chatListDiv.innerHTML = '<p>Error loading chats. Please try again.</p>';
                        setTimeout(() => window.location.href = '/login.html', 2000);
                    });
            }

            const stompClient = new StompJs.Client({
                //brokerURL: `wss://${window.location.hostname}/websocket`
                brokerURL: `ws://${window.location.hostname}:8080/websocket`
            });
            stompClient.activate();
            stompClient.onConnect = (frame) => {
                console.log('Connected for detecting incoming messages: ' + frame);
                const userId = localStorage.getItem('userId');
                stompClient.subscribe(`/topic/toggle-refresh/${userId}`, (message) => {
                    const refreshSignal = JSON.parse(message.body); // Parse the message payload (Boolean.TRUE)
                    console.log(refreshSignal)
                    if (refreshSignal === true) {
                        loadNewChatList();
                    }
                });

            }

            function loadNewChatList() {
                fetch(`/api/chat-list/chats`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to fetch chats: ' + response.status);
                        }
                        return response.json();
                    })
                    .then(chats => {
                        if (chats.length === 0) {
                            const existingItems = chatListDiv.querySelectorAll('.chat-list-item');
                            const existingChatMap = new Map();

                            // Build a map of existing chats for comparison
                            existingItems.forEach(item => {
                                const chatId = item.getAttribute('data-chat-id');
                                const subject = item.querySelector('.chat-list-subject').textContent.trim().replace(/\s+$/, ''); // Trim unread mark
                                const lastMessage = item.querySelector('.chat-list-last-message').textContent.split('"')[1];
                                const timeDisplay = item.querySelector('.chat-list-last-message span').textContent;
                                const unread = !!item.querySelector('.unread-mark');
                                existingChatMap.set(chatId, { subject, lastMessage, timeDisplay, unread });
                            });

                            // Create a fragment to hold all new/updated items in the correct order
                            const fragment = document.createDocumentFragment();

                            // Process new chats in server-provided order (earliest to latest)
                            newChats.forEach(chat => {
                                const timeDisplay = formatTime(chat.lastMessageTime);
                                const unreadMark = shouldShowUnread(chat.lastMessageTime, chat.lastReadAt) ? '<span class="unread-mark"></span>' : '';
                                const newHtml = `
            <div class="chat-list-item" data-chat-id="${chat.chatRoomId}">
              <a class="chat-list-subject" href="/chat-room.html?chatRoomId=${chat.chatRoomId}">
                ${chat.chatRoomName}
                ${unreadMark}
              </a>
              <p class="chat-list-last-message">
                "${chat.lastMessage || 'No messages yet'}"
                <span>${timeDisplay}</span>
              </p>
              <div class="chat-divider"></div>
            </div>
          `;

                                const existing = existingChatMap.get(chat.chatRoomId);
                                const existingItem = chatListDiv.querySelector(`.chat-list-item[data-chat-id="${chat.chatRoomId}"]`);

                                const newItem = document.createRange().createContextualFragment(newHtml).firstElementChild;

                                if (existing && existingItem) {
                                    // Compare and update only if changed
                                    const hasChanged = existing.subject !== chat.chatRoomName ||
                                        existing.lastMessage !== (chat.lastMessage || 'No messages yet') ||
                                        existing.timeDisplay !== timeDisplay ||
                                        existing.unread !== !!unreadMark;

                                    if (hasChanged) {
                                        existingItem.style.transition = 'opacity 0.2s ease';
                                        existingItem.style.opacity = '0';
                                        setTimeout(() => {
                                            chatListDiv.replaceChild(newItem, existingItem);
                                            newItem.style.opacity = '0';
                                            newItem.style.transition = 'opacity 0.2s ease';
                                            requestAnimationFrame(() => {
                                                newItem.style.opacity = '1';
                                            });
                                        }, 200);
                                        return; // Skip adding to fragment since we updated in place
                                    }
                                } else if (!existing) {
                                    // New chat: Fade in
                                    newItem.style.opacity = '0';
                                    newItem.style.transition = 'opacity 0.2s ease';
                                    fragment.appendChild(newItem);
                                    requestAnimationFrame(() => {
                                        newItem.style.opacity = '1';
                                    });
                                }

                                // If unchanged, keep the existing item in the fragment
                                if (existing && !hasChanged) {
                                    fragment.appendChild(existingItem.cloneNode(true));
                                }
                            });

                            // Replace entire list with the new ordered fragment
                            chatListDiv.innerHTML = '';
                            chatListDiv.appendChild(fragment);

                            // Remove chats that no longer exist
                            existingItems.forEach(item => {
                                const chatId = item.getAttribute('data-chat-id');
                                if (!newChats.some(chat => chat.chatRoomId === chatId)) {
                                    item.style.transition = 'opacity 0.2s ease';
                                    item.style.opacity = '0';
                                    setTimeout(() => {
                                        item.remove();
                                    }, 200);
                                }
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        chatListDiv.innerHTML = '<p>Error loading chats. Please try again.</p>';
                        setTimeout(() => window.location.href = '/login.html', 2000);
                    });
            }

            function formatTime(lastMessageTime) {
                if (!lastMessageTime) return "No time available";
                const messageTime = new Date(lastMessageTime);
                const now = new Date();
                const diffMs = now - messageTime;
                const diffMin = Math.floor(diffMs / (1000 * 60));
                const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                if (diffMin < 60) {
                    return diffMin < 1 ? "just now" : `${diffMin} min ago`;
                } else if (diffHours < 24) {
                    return diffHours === 1 ? "1 hour ago" : `${diffHours} hours ago`;
                } else if (diffDays <= 14) {
                    return diffDays === 1 ? "1 day ago" : `${diffDays} days ago`;
                } else {
                    return messageTime.toLocaleDateString('en-CA');
                }
            }

            function shouldShowUnread(lastMessageTime, lastReadAt) {
                if (!lastMessageTime) return false;
                if (!lastReadAt) return true;
                return new Date(lastMessageTime) > new Date(lastReadAt);
            }

            function logout(event) {
                event.preventDefault();
                fetch('/api/user/logout', { method: 'POST' })
                    .then(() => window.location.href = '/login.html');
            }
        });
    </script>
</head>
<body>
<div class="container">
    <h2>Your Chats</h2>
    <hr>
    <div id="chatList">
        <!-- Chat items or empty message will be populated here -->
    </div>
    <div class="chat-actions">
        <button onclick="window.location.href='find-user.html'">Search Users</button>
        <a href="login.html" onclick="logout(event)" class="logout-link">Logout</a>
    </div>
</div>
<p class="footer">A chat service by Seunghyun Yoo.</p>
</body>
</html>